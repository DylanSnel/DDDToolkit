using DDDToolkit.Abstractions.Attributes;
using DDDToolkit.EntityFramework.Analyzers.Models;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using SourceGeneratorsToolkit;
using SourceGeneratorsToolkit.Providers;
using SourceGeneratorsToolkit.SyntaxExtensions;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

namespace DDDToolkit.EntityFramework.Analyzers.Generators;

[Generator]
public class SingleValueObjectConverterGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {

        //#if DEBUG
        //        if (!System.Diagnostics.Debugger.IsAttached)
        //        {
        //            System.Diagnostics.Debugger.Launch();
        //        }
        //#endif

        var dddPropteriesProvider = context.AnalyzerConfigOptionsProvider
             .Select((provider, _) =>
             {
                 var options = provider.ToProvider("build_property.ddd_");
                 return new DDDOptions
                 {
                     ModuleName = options.GetOption("module", string.Empty),
                 };
             });


        var singleValueObjects = context.FindAttributesProvider<SingleValueObjectAttribute, RecordDeclarationSyntax, GenericObjectDefinition>(
              transform: static (ctx, _) =>
              {
                  var classDeclaration = ctx.TargetNode as RecordDeclarationSyntax;
                  GenericObjectDefinition singleValueObjectDefinition = new()
                  {
                      Name = classDeclaration!.Identifier.Text,
                      Namespace = classDeclaration.Parent is BaseNamespaceDeclarationSyntax namespaceDeclaration ? namespaceDeclaration.Name.ToString() : "",
                      Type = ctx.Attributes.First(x => x.match).attribute.GenericTypes.First().Name,
                      Arguments = ctx.Attributes.First(x => x.match).attribute.Arguments,
                      AccessModifier = classDeclaration.GetAccessModifier(),
                  };
                  if (singleValueObjectDefinition.Type == "String")
                  {
                      singleValueObjectDefinition.Type = "string";
                  }

                  return singleValueObjectDefinition;

              });
        var entityIds = context.FindAttributesProvider<EntityIdAttribute, RecordDeclarationSyntax, GenericObjectDefinition>(
              transform: static (ctx, _) =>
              {
                  var classDeclaration = ctx.TargetNode as RecordDeclarationSyntax;
                  GenericObjectDefinition singleValueObjectDefinition = new()
                  {
                      Name = classDeclaration!.Identifier.Text,
                      Namespace = classDeclaration.Parent is BaseNamespaceDeclarationSyntax namespaceDeclaration ? namespaceDeclaration.Name.ToString() : "",
                      Type = ctx.Attributes.First(x => x.match).attribute.GenericTypes.First().Name,
                      AccessModifier = classDeclaration.GetAccessModifier(),
                  };
                  if (singleValueObjectDefinition.Type == "String")
                  {
                      singleValueObjectDefinition.Type = "string";
                  }

                  return singleValueObjectDefinition;

              });


        context.RegisterSourceOutput(singleValueObjects, GenerateValueConverter);
        context.RegisterSourceOutput(entityIds, GenerateValueConverter);

        var classes = singleValueObjects.Collect().Combine(entityIds.Collect()).SelectMany((x, y) => x.Left.Concat(x.Right));

        var classesWithProperties = dddPropteriesProvider.Combine(classes.Collect());
        var classesWithPropertiesAndCompilation = classesWithProperties.Combine(context.CompilationProvider);

        context.RegisterSourceOutput(classesWithPropertiesAndCompilation, GenerateConfigurationExtensions);
    }
    private static void GenerateValueConverter(SourceProductionContext context, GenericObjectDefinition data)
    {

        var converterName = $"{data.Name}Converter";

        var sourceCode = $$$"""
                            // <auto-generated/>
                            using Microsoft.EntityFrameworkCore.Storage.ValueConversion;

                            namespace {{{data.Namespace}}};
    
                            {{{data.AccessModifier}}} partial record {{{data.Name}}} 
                            {
                                public class {{{converterName}}} : ValueConverter<{{{data.Name}}}, {{{data.Type}}}>
                                {
                                    public {{{converterName}}}()
                                        : base(
                                            v => v.Value,
                                            v => new {{{data.Name}}}(v))
                                    {
                                    }
                                }
                            }
                            """;

        context.AddSource($"{data.Namespace}.{converterName}.g.cs", SourceText.From(sourceCode, Encoding.UTF8));
    }



    private static void GenerateConfigurationExtensions(SourceProductionContext sourceContext, ((DDDOptions Properties, ImmutableArray<GenericObjectDefinition> records) data, Compilation compilation) context)
    {
        var records = context.data.records;
        var properties = context.data.Properties;
        var compilation = context.compilation;
        if (records.Length == 0)
        {
            return;
        }

        var distinctNamespaces = records.Select(c => c.Namespace).Distinct();
        var assemblyName = compilation.AssemblyName;
        var moduleName = properties.ModuleName;

        if (string.IsNullOrEmpty(moduleName))
        {
            moduleName = CreateModuleName(assemblyName);
        }
        var usingStatements = string.Join("\n", distinctNamespaces.Select(ns => $"using {ns};"));
        var propertiesConfigurations = string.Join("\n        ", records.Select(c => $"modelConfigurationBuilder.Properties<{c.Name}>().HaveConversion<{c.Name}.{c.Name}Converter>(){AddMaxlenght(c)};"));

        var sourceCode = $$"""
            // <auto-generated/>
            {{usingStatements}}
            using Microsoft.EntityFrameworkCore;

            namespace {{assemblyName}}.Converters;
            
            public static class ConverterExtensions
            {
                public static void Add{{moduleName}}Converters(this ModelConfigurationBuilder modelConfigurationBuilder)
                {
                    {{propertiesConfigurations}}
                }
            }
            """;

        sourceContext.AddSource("ConverterExtensions.g.cs", SourceText.From(sourceCode, Encoding.UTF8));
    }

    private static string AddMaxlenght(GenericObjectDefinition record)
    {
        if ((record.Arguments?.TryGetValue("ColumnLength", out var value) ?? false) && ((int)value.Value! > -1))
        {
            return $".HaveMaxLength({value.Value})";
        }
        return "";
    }

    private static string CreateModuleName(string? assemblyName)
        => assemblyName is null
            ? "AssemblyTypes"
            : assemblyName.Replace(".", string.Empty);
}
