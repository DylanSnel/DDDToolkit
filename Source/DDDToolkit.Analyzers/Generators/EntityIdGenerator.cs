using DDDToolkit.Abstractions.Attributes;
using DDDToolkit.Analyzers.Models;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using SourceGeneratorsToolkit.SyntaxExtensions;
using SourceGeneratorsToolkit.SyntaxExtensions.Attributes;
using System.Linq;
using System.Text;

[Generator]
public class EntityIdGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        //#if DEBUG
        //        if (!System.Diagnostics.Debugger.IsAttached)
        //        {

        //            System.Diagnostics.Debugger.Launch();
        //        }
        //#endif

        var entityIds = context.FindAttributesProvider<EntityIdAttribute, ClassDeclarationSyntax, GenericObjectDefinition>(
              transform: static (ctx, _) =>
              {
                  var classDeclaration = ctx.TargetNode as ClassDeclarationSyntax;
                  GenericObjectDefinition entityIdDefinition = new()
                  {
                      Name = classDeclaration!.Identifier.Text,
                      Namespace = classDeclaration.Parent is BaseNamespaceDeclarationSyntax namespaceDeclaration ? namespaceDeclaration.Name.ToString() : "",
                      Type = ctx.Attributes.First(x => x.match).attribute.GenericTypes.First().Name,
                      AccessModifier = classDeclaration.GetAccessModifier(),
                  };
                  if (entityIdDefinition.Type == "String")
                  {
                      entityIdDefinition.Type = "string";
                  }

                  return entityIdDefinition;

              });
        context.RegisterSourceOutput(entityIds, Execute);
    }

    private static void Execute(SourceProductionContext context, GenericObjectDefinition data)
    {
        var sourceCode = $$$"""
                            // <auto-generated/>
                            using FluentResults;
                            using DDDToolkit.BaseTypes;
                            using DDDToolkit.Abstractions.Interfaces;

                            #nullable enable
                            namespace {{{data.Namespace}}};
    
                            {{{data.AccessModifier}}} partial class {{{data.Name}}} : EntityId<{{{data.Type}}}>, IEntityId
                            {
                                private {{{data.Name}}}({{{data.Type}}} value) : base(value)
                                {
                                }

                                public static bool operator ==({{{data.Name}}} left, {{{data.Name}}} right)
                                {
                                    return Equals(left, right);
                                }

                                public static bool operator !=({{{data.Name}}} left, {{{data.Name}}} right)
                                {
                                    return !Equals(left, right);
                                }

                                public override int GetHashCode()
                                    => base.GetHashCode();

                                public override bool Equals(object? obj)
                                    => base.Equals(obj);

                                public static Result<{{{data.Name}}}> Create({{{data.Type}}} value)
                                {
                                    var obj = new {{{data.Name}}}(value);
                                    obj.Value = obj.Transform(value);
                                    var result = obj.Validate(obj.Value);
                                    if (result.IsFailed)
                                    {
                                        return result.ToResult<{{{data.Name}}}>();
                                    }
                                    return obj;
                                }

                                {{{(data.Type == "Guid" ?
                                $$$"""
                                   public static {{{data.Name}}} CreateUnique() => new(Guid.NewGuid());
                                """ : "")}}}  

                                {{{(data.Type != "string" ?
                                $$$"""
                                   public static Result<{{{data.Name}}}?> Create({{{data.Type}}}? value)
                                   {
                                       if(!value.HasValue)
                                       {
                                           return Result.Ok<{{{data.Name}}}?>(null);
                                       }
                                       return Create(value.Value);
                                    }
                                """ : "")}}}     
                            }
    
                            """;
        // Add the generated source to the compilation
        context.AddSource($"{data.Namespace}.{data.Name}.g.cs", SourceText.From(sourceCode, Encoding.UTF8));
    }

}
