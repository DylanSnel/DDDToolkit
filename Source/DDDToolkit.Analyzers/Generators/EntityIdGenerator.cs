using DDDToolkit.Abstractions.Attributes;
using DDDToolkit.Analyzers.Common;
using DDDToolkit.Analyzers.Models;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using SourceGeneratorsToolkit;
using SourceGeneratorsToolkit.Providers;
using SourceGeneratorsToolkit.Providers.Contexts;
using SourceGeneratorsToolkit.SyntaxExtensions;
using System.Linq;
using System.Text;
using static DDDToolkit.Analyzers.Generators.ValueObjectGenerator;

namespace DDDToolkit.Analyzers.Generators;

[Generator]
public class EntityIdGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        //#if DEBUG
        //        if (!System.Diagnostics.Debugger.IsAttached)
        //        {

        //            System.Diagnostics.Debugger.Launch();
        //        }
        //#endif
        var dddOptions = context.DDDOptionsProvider();
        var entityIds = context.FindAttributesProvider<EntityIdAttribute, RecordDeclarationSyntax>();
        var combined = entityIds.Combine(dddOptions);
        context.RegisterSourceOutput(combined, Execute);
    }

    private static void Execute(SourceProductionContext context, (ResultTypeAttributeSyntaxContext data, DDDOptions options) arguments)
    {
        var (data, options) = arguments;
        var recordDeclaration = data.TargetNode as RecordDeclarationSyntax;
        if (recordDeclaration is null)
        {
            context.ReportDiagnostic(Diagnostic.Create(Diagnostics.ValueObjectShouldBeRecord, data.TargetNode.GetLocation(), data.TargetSymbol.Name));
            return;
        }
        if (recordDeclaration.IsSealed())
        {
            context.ReportDiagnostic(Diagnostic.Create(Diagnostics.ValueObjectsCantBeSealed, recordDeclaration.GetLocation(), data.TargetSymbol.Name));
            return;
        }

        var valueObjectInfo = new ValueObjectInfo(recordDeclaration, options);
        var type = data.Attributes.First(x => x.match).attribute.GenericTypes.First().Name;
        var attributeArguments = data.Attributes.First(x => x.match).attribute.Arguments;
        var prefix = attributeArguments.TryGetValue("Prefix", out var value) ? value!.Value!.ToString() : "";

        var sourceCode = $$$"""
                            // <auto-generated/>
                            using DDDToolkit.BaseTypes;
                            using System.Text.Json.Serialization;
                            using DDDToolkit.Abstractions.Interfaces;
                            using DDDToolkit.Abstractions.Attributes;

                            #nullable enable
                            #pragma warning disable CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.
                            namespace {{{valueObjectInfo.Namespace}}};
    
                            partial record {{{valueObjectInfo.Name}}} : EntityId<{{{type}}}>
                            {
                                protected {{{valueObjectInfo.Name}}}({{{type}}} value) : base(value, "{{{prefix}}}")
                                {
                                }

                                [JsonConstructor]
                                protected {{{valueObjectInfo.Name}}}() : base("{{{prefix}}}")
                                {
                                }

                                 public virtual bool Equals({{{valueObjectInfo.Name}}}? other)
                                    {
                                        if (other is null)
                                        {
                                            return false;
                                        }
                                        return GetEqualityComponents().SequenceEqual(other.GetEqualityComponents());
                                    }
                            
                                public override int GetHashCode()
                                    => base.GetHashCode();

                            {{{(type == "Guid" ?
                         $$$"""
                                public static {{{valueObjectInfo.Name}}} CreateUnique() => new(Guid.NewGuid());
                            """ : "")}}}  

                            public Valid{{{valueObjectInfo.Name}}} ToValid() => new(this);
                    
                            }
                            {{{AddAlwaysValid(valueObjectInfo, type)}}}
                            #pragma warning restore CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.2
                            """;
        sourceCode = CodeFormatter.FormatSourceCode(sourceCode);
        // Add the generated source to the compilation
        context.AddSource($"{valueObjectInfo.Namespace}.{valueObjectInfo.Name}.g.cs", SourceText.From(sourceCode, Encoding.UTF8));
    }

    private static string AddAlwaysValid(ValueObjectInfo valueObjectInfo, string type)
    {
        return $$$"""
                   

                    {{{valueObjectInfo.AccessModifier}}} partial record Valid{{{valueObjectInfo.Name}}}  : {{{valueObjectInfo.Name}}}, IAlwaysValid
                    {

                        {{{valueObjectInfo.AccessModifier}}} Valid{{{valueObjectInfo.Name}}}({{{valueObjectInfo.Name}}} value)
                        {
                            value.EnsureValidated();
                            this.Value = value.Value;
                            _isValid = true;
                        }

                        public Valid{{{valueObjectInfo.Name}}}({{{type}}} value) : base(value)
                        {
                            EnsureValidated();
                        }
                       
                        public virtual bool Equals(Valid{{{valueObjectInfo.Name}}}? other)
                        {
                            if (other is null)
                            {
                                return false;
                            }
                            return GetEqualityComponents().SequenceEqual(other.GetEqualityComponents());
                        }

                        public override int GetHashCode()
                            => base.GetHashCode();
                    }
            """;
    }

}
