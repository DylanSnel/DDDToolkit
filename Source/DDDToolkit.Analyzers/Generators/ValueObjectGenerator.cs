using DDDToolkit.Abstractions.Attributes;
using DDDToolkit.Abstractions.Attributes.Validation;
using DDDToolkit.Analyzers.Common;
using DDDToolkit.Analyzers.Models;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using SourceGeneratorsToolkit.Providers;
using SourceGeneratorsToolkit.Providers.Contexts;
using SourceGeneratorsToolkit.SyntaxExtensions;
using System.Linq;
using System.Text;

namespace DDDToolkit.Analyzers.Generators;

[Generator]
public class ValueObjectGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        //#if DEBUG
        //        if (!System.Diagnostics.Debugger.IsAttached)
        //        {

        //            System.Diagnostics.Debugger.Launch();
        //        }
        //#endif

        var dddOptions = context.DDDOptionsProvider();
        var singleValueObjects = context.FindAttributesProvider<ValueObjectAttribute, RecordDeclarationSyntax>();
        var combined = singleValueObjects.Combine(dddOptions);
        context.RegisterSourceOutput(combined, CreateValueObject);
    }

    private static void CreateValueObject(SourceProductionContext context, (TypeAttributeSyntaxContext data, DDDOptions options) arguments)
    {
        var (data, options) = arguments;
        var recordDeclaration = data.TargetNode as RecordDeclarationSyntax;
        if (recordDeclaration is null)
        {
            context.ReportDiagnostic(Diagnostic.Create(Diagnostics.ValueObjectShouldBeRecord, data.TargetNode.GetLocation(), data.TargetSymbol.Name));
            return;
        }

        var hasAlwaysValidAttribute = recordDeclaration.HasAttribute<AlwaysValidAttribute>();
        var hasAllowInvalidAttribute = recordDeclaration.HasAttribute<AllowInvalidAttribute>();

        if (hasAlwaysValidAttribute && hasAllowInvalidAttribute)
        {
            context.ReportDiagnostic(Diagnostic.Create(Diagnostics.ValueObjectCannotHaveAlwaysValidAndAllowInvalid, data.TargetNode.GetLocation(), data.TargetSymbol.Name));
            return;
        }

        var alwaysValid = hasAlwaysValidAttribute || options.AlwaysValidValueObjects;
        alwaysValid = alwaysValid && !hasAllowInvalidAttribute;


        var name = recordDeclaration.GetName();
        var @namespace = recordDeclaration.GetNamespace();
        var accessModifier = recordDeclaration.GetAccessModifier();
        var properties = recordDeclaration.GetProperties();
        var propertiesWithoutIgnore = properties.Where(x => !x.Attributes().Any(a => a.Matches<DontCompareAttribute>()));

        var equalityComponents = string.Join("\n        ", propertiesWithoutIgnore.Select(x => $"yield return {x.GetName()};"));

        var virtualEquals = recordDeclaration.IsSealed() ? "" : "virtual ";


        var sourceCode = $$$"""
                            // <auto-generated/>
                            using DDDToolkit.BaseTypes;
                            using System.Text.Json.Serialization;

                            #nullable enable
                            #pragma warning disable CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.

                            namespace {{{@namespace}}};
    
                            {{{recordDeclaration.SealedModifier()}}}partial record {{{name}}} : ValueObject
                            {
                                public override IEnumerable<object?> GetEqualityComponents()
                                {
                                    {{{equalityComponents}}}
                                }
                            
                                public {{{virtualEquals}}}bool Equals({{{name}}}? other)
                                {
                                    if (other is null)
                                    {
                                        return false;
                                    }
                                    return GetEqualityComponents().SequenceEqual(other.GetEqualityComponents());
                                }

                                public override int GetHashCode()
                                    => GetEqualityComponents()
                                        .Select(x => x?.GetHashCode() ?? 0)
                                        .Aggregate((x, y) => x ^ y);

                                [JsonConstructor]
                                protected {{{name}}}()
                                {

                                }
                            }
                            #pragma warning restore CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.
    
                            """;
        // Add the generated source to the compilation
        context.AddSource($"{@namespace}.{name}.g.cs", SourceText.From(sourceCode, Encoding.UTF8));
    }

}
