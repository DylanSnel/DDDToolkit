using DDDToolkit.Abstractions.Attributes;
using DDDToolkit.Abstractions.Attributes.Validation;
using DDDToolkit.Analyzers.Common;
using DDDToolkit.Analyzers.Models;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using SourceGeneratorsToolkit;
using SourceGeneratorsToolkit.Providers;
using SourceGeneratorsToolkit.Providers.Contexts;
using SourceGeneratorsToolkit.SyntaxExtensions;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace DDDToolkit.Analyzers.Generators;

[Generator]
public class ValueObjectGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
#if DEBUG
        if (!System.Diagnostics.Debugger.IsAttached)
        {

            System.Diagnostics.Debugger.Launch();
        }
#endif

        var dddOptions = context.DDDOptionsProvider();
        var singleValueObjects = context.FindAttributesProvider<ValueObjectAttribute, RecordDeclarationSyntax>();
        var combined = singleValueObjects.Combine(dddOptions);
        context.RegisterSourceOutput(combined, CreateValueObject);
    }

    private static void CreateValueObject(SourceProductionContext context, (TypeAttributeSyntaxContext data, DDDOptions options) arguments)
    {
        var (data, options) = arguments;
        var recordDeclaration = data.TargetNode as RecordDeclarationSyntax;
        if (recordDeclaration is null)
        {
            context.ReportDiagnostic(Diagnostic.Create(Diagnostics.ValueObjectShouldBeRecord, data.TargetNode.GetLocation(), data.TargetSymbol.Name));
            return;
        }

        var valueObjectInfo = new ValueObjectInfo(recordDeclaration, options);

        // Now you can use valueObjectInfo for further processing
        // For example, to check for conflicting attributes:
        if (valueObjectInfo.HasAlwaysValidAttribute && valueObjectInfo.HasAllowInvalidAttribute)
        {
            context.ReportDiagnostic(Diagnostic.Create(Diagnostics.ValueObjectCannotHaveAlwaysValidAndAllowInvalid, data.TargetNode.GetLocation(), valueObjectInfo.Name));
            return;
        }


        var virtualEquals = recordDeclaration.IsSealed() ? "" : "virtual ";


        var sourceCode = $$$"""
                            // <auto-generated/>
                            using DDDToolkit.BaseTypes;
                            using System.Text.Json.Serialization;
                            using DDDToolkit.Abstractions.Interfaces;
                            using DDDToolkit.Abstractions.Attributes;

                            #nullable enable
                            #pragma warning disable CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.

                            namespace {{{valueObjectInfo.Namespace}}};
    
                            {{{recordDeclaration.SealedModifier()}}}partial record {{{valueObjectInfo.Name}}} : ValueObject<I{{{valueObjectInfo.Name}}}>, {{{valueObjectInfo.ValidityInterface}}}, I{{{valueObjectInfo.Name}}}
                            {
                                public override IEnumerable<object?> GetEqualityComponents()
                                {
                                    {{{string.Join("\n       ", valueObjectInfo.EqualityComponents)}}}
                                }
                            
                                public {{{virtualEquals}}}bool Equals({{{valueObjectInfo.Name}}}? other)
                                {
                                    if (other is null)
                                    {
                                        return false;
                                    }
                                    return GetEqualityComponents().SequenceEqual(other.GetEqualityComponents());
                                }

                                public override int GetHashCode()
                                    => GetEqualityComponents()
                                        .Select(x => x?.GetHashCode() ?? 0)
                                        .Aggregate((x, y) => x ^ y);

                                [JsonConstructor]
                                protected {{{valueObjectInfo.Name}}}()
                                {

                                }
                                {{{AddAlwaysValid(valueObjectInfo)}}}
                            }

                            public interface I{{{valueObjectInfo.Name}}} : IValueObject<I{{{valueObjectInfo.Name}}}>
                            {
                                {{{string.Join("\n", valueObjectInfo.InterfaceProperties.Select(x => $"{x.GetReturnType().Replace("?", "")}? {x.Identifier.ValueText} {{ get; }}"))}}}
                            }

                            #pragma warning restore CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.
    
                            """;

        sourceCode = CodeFormatter.FormatSourceCode(sourceCode);
        // Add the generated source to the compilation
        context.AddSource($"{valueObjectInfo.Namespace}.{valueObjectInfo.Name}.g.cs", SourceText.From(sourceCode, Encoding.UTF8));
    }

    private static string AddAlwaysValid(ValueObjectInfo valueObjectInfo)
    {
        if (!valueObjectInfo.AlwaysValid)
        {
            return "";
        }

        // Handling for regular and computed properties
        var propertiesWithNullableTypes = valueObjectInfo.ConverterConstructorProperties.Select(property =>
        {
            var typeName = property.GetReturnType();
            typeName = typeName.Replace("?", "");
            return $"public {typeName}? {property.Identifier.ValueText} {{ get; set; }}";
        }).ToList();

        // Special handling for computed properties to ensure they are nullable
        var computedProperties = valueObjectInfo.RecordDeclaration.GetProperties()
            .Where(p => !p.HasAttribute<InternalAttribute>())
            .Where(p => p.ExpressionBody != null || p.AccessorList!.Accessors.Any(a => a.Body != null || a.ExpressionBody != null))
            .Select(computedProperty =>
            {
                var typeName = computedProperty.GetReturnType();
                typeName.Replace("?", "");

                return $"public {typeName}? {computedProperty.Identifier.ValueText} => {computedProperty.ExpressionBody?.Expression.ToString() ?? "null"};";
            });

        propertiesWithNullableTypes.AddRange(computedProperties);

        var propertiesInitialization = valueObjectInfo.ConverterConstructorProperties.Select(x =>
            $"this.{x.Identifier.ValueText} = raw.{x.Identifier.ValueText}!;");

        return $$$"""
                    {{{valueObjectInfo.AccessModifier}}} {{{valueObjectInfo.Name}}}(Raw raw)
                    {
                        raw.EnsureValidated();
                        {{{string.Join("\n", propertiesInitialization)}}}
                        _isValid = true;
                    }

                    {{{valueObjectInfo.AccessModifier}}} partial record Raw : ValueObject<I{{{valueObjectInfo.Name}}}>, IRaw, I{{{valueObjectInfo.Name}}}
                    {
                        {{{string.Join("\n", propertiesWithNullableTypes)}}}

                        public Raw()
                        {
                        }

                        public override bool Validate(I{{{valueObjectInfo.Name}}} valueObject)
                        {
                            var parentObject = new {{{valueObjectInfo.Name}}}();
                            return parentObject.Validate(valueObject);
                        }

                        public static implicit operator {{{valueObjectInfo.Name}}}(Raw raw) => new(raw);

                        [Internal]
                        public override IEnumerable<object?> GetEqualityComponents()
                        {
                            {{{string.Join("\n       ", valueObjectInfo.EqualityComponents)}}}
                        }

                        public virtual bool Equals(Raw? other)
                        {
                            if (other is null)
                            {
                                return false;
                            }
                            return GetEqualityComponents().SequenceEqual(other.GetEqualityComponents());
                        }

                        public override int GetHashCode()
                            => GetEqualityComponents()
                                .Select(x => x?.GetHashCode() ?? 0)
                                .Aggregate((x, y) => x ^ y);
                    }
            """;
    }


    internal class ValueObjectInfo
    {
        public RecordDeclarationSyntax RecordDeclaration { get; }
        public DDDOptions Options { get; }

        public bool HasAlwaysValidAttribute => RecordDeclaration.HasAttribute<AlwaysValidAttribute>();
        public bool HasAllowInvalidAttribute => RecordDeclaration.HasAttribute<AllowInvalidAttribute>();
        public bool AlwaysValid => (HasAlwaysValidAttribute || Options.AlwaysValidValueObjects) && !HasAllowInvalidAttribute;
        public string Name => RecordDeclaration.Identifier.ValueText;
        public string Namespace => RecordDeclaration.GetNamespace();
        public string AccessModifier => RecordDeclaration.GetAccessModifier();
        public IEnumerable<PropertyDeclarationSyntax> InterfaceProperties => RecordDeclaration.GetProperties()
            .Where(prop => !prop.HasAttribute<InternalAttribute>());
        public IEnumerable<PropertyDeclarationSyntax> ComparisonProperties => InterfaceProperties
            .Where(prop => !prop.HasAttribute<DontCompareAttribute>());
        public IEnumerable<PropertyDeclarationSyntax> ConverterConstructorProperties => InterfaceProperties.Where(x => x.HasSetter());
        public IEnumerable<string> EqualityComponents => ComparisonProperties
            .Select(prop => $"yield return {prop.Identifier.ValueText};");
        public string ValidityInterface => AlwaysValid ? "IAlwaysValid" : "IAllowInvalid";

        public ValueObjectInfo(RecordDeclarationSyntax recordDeclaration, DDDOptions options)
        {
            RecordDeclaration = recordDeclaration;
            Options = options;
        }
    }

}
