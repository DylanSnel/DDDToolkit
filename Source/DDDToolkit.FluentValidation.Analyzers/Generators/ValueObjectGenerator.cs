using DDDToolkit.Abstractions.Attributes;
using DDDToolkit.Analyzers.Common;
using DDDToolkit.Analyzers.Models;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using SourceGeneratorsToolkit;
using SourceGeneratorsToolkit.Providers;
using SourceGeneratorsToolkit.Providers.Contexts;
using SourceGeneratorsToolkit.SyntaxExtensions;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace DDDToolkit.FluentValidation.Analyzers.Generators;

[Generator]
public class ValueObjectGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        //#if DEBUG
        //        if (!System.Diagnostics.Debugger.IsAttached)
        //        {

        //            System.Diagnostics.Debugger.Launch();
        //        }
        //#endif

        var dddOptions = context.DDDOptionsProvider();
        var valueObjects = context.FindAttributesProvider<ValueObjectAttribute, RecordDeclarationSyntax>();
        var singleValueObjects = context.FindAttributesProvider<SingleValueObjectAttribute, RecordDeclarationSyntax>();
        var entityIdValueObjects = context.FindAttributesProvider<EntityIdAttribute, RecordDeclarationSyntax>();
        var allValueObjects = valueObjects.Concat(singleValueObjects).Concat(entityIdValueObjects);
        var combined = allValueObjects.Combine(dddOptions);
        context.RegisterSourceOutput(combined, CreateValueObject);
    }

    private static void CreateValueObject(SourceProductionContext context, (ResultTypeAttributeSyntaxContext data, DDDOptions options) arguments)
    {
        var (data, options) = arguments;
        var recordDeclaration = data.TargetNode as RecordDeclarationSyntax;
        if (recordDeclaration is null)
        {
            return;
        }

        var valueObjectInfo = new ValueObjectInfo(recordDeclaration, options);

        var sourceCode = $$$"""
                            // <auto-generated/>
                            using DDDToolkit.Abstractions.Attributes;
                            using FluentValidation;
                            using FluentValidation.Results;
                            using System.Collections.ObjectModel;
                            using System.ComponentModel.DataAnnotations.Schema;

                            namespace {{{valueObjectInfo.Namespace}}};
    
                            partial record {{{valueObjectInfo.Name}}}
                            {
                                [Internal]
                                [NotMapped]
                                public ReadOnlyCollection<ValidationFailure> Errors => _errors.AsReadOnly();

                                private List<ValidationFailure> _errors = [];
                                protected override bool Validate()
                                {
                                    var validator = new Validator();
                                    var result = validator.Validate(this);
                                    _errors = result.Errors;
                                    return result.IsValid;
                                }

                                partial class Validator : AbstractValidator<{{{valueObjectInfo.Name}}}>
                                {

                                }
                            }
    
                            """;

        sourceCode = CodeFormatter.FormatSourceCode(sourceCode);
        // Add the generated source to the compilation
        context.AddSource($"{valueObjectInfo.Namespace}.{valueObjectInfo.Name}.g.cs", SourceText.From(sourceCode, Encoding.UTF8));
    }

    internal class ValueObjectInfo(RecordDeclarationSyntax recordDeclaration, DDDOptions options)
    {
        public RecordDeclarationSyntax RecordDeclaration { get; } = recordDeclaration;
        public DDDOptions Options { get; } = options;

        public string Name => RecordDeclaration.GetName();
        public string Namespace => RecordDeclaration.GetNamespace();
        public string AccessModifier => RecordDeclaration.GetAccessModifier();
        public IEnumerable<PropertyDeclarationSyntax> InterfaceProperties => RecordDeclaration.GetProperties()
            .Where(prop => !prop.HasAttribute<InternalAttribute>());
        public IEnumerable<PropertyDeclarationSyntax> ComparisonProperties => InterfaceProperties
            .Where(prop => !prop.HasAttribute<DontCompareAttribute>());
        public IEnumerable<PropertyDeclarationSyntax> ConverterConstructorProperties => InterfaceProperties.Where(x => x.HasSetter());
        public IEnumerable<string> EqualityComponents => ComparisonProperties
            .Select(prop => $"yield return {prop.Identifier.ValueText};");
    }

}
